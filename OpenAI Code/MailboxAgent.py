#################################################################################################
### COMP1811 - CW1 Outlook Simulator                                                          ###
###            MailboxAgent class                                                            ###
###            Manages mailbox and operations                                                ###
#################################################################################################

from Mail import Mail
from Confidential import Confidential
from Personal import Personal

class MailboxAgent:
    """Agent managing the mailbox â€” stores Mail objects and implements operations required by the spec."""

    def __init__(self, email_data_list):
        """
        email_data_list: list of strings as generated by gen_emails()
        We'll parse and populate _mailbox with Mail/Confidential/Personal objects based on Tag.
        """
        self._mailbox = []
        self.__gen_mailbox(email_data_list)

    def __gen_mailbox(self, email_data_list):
        """Parse the list of email strings (each a chunk containing many emails) and create Mail objects."""
        # email_data_list contains many messages; each message contains many email entries separated by lines.
        for chunk in email_data_list:
            # split into lines and collect blocks starting with ID:
            lines = [ln.strip() for ln in chunk.splitlines() if ln.strip() != ""]
            current = {}
            for ln in lines:
                if ln.startswith("ID:"):
                    # if we have a current block, create object
                    if current:
                        self._create_and_append(current)
                        current = {}
                    current['ID'] = ln[len("ID:"):].strip()
                elif ln.startswith("From:"):
                    current['From'] = ln[len("From:"):].strip()
                elif ln.startswith("To:"):
                    current['To'] = ln[len("To:"):].strip()
                elif ln.startswith("Date:"):
                    current['Date'] = ln[len("Date:"):].strip()
                elif ln.startswith("Subject:"):
                    current['Subject'] = ln[len("Subject:"):].strip()
                elif ln.startswith("Tag:"):
                    current['Tag'] = ln[len("Tag:"):].strip()
                elif ln.startswith("Body:"):
                    # Body may include text after "Body:"
                    current['Body'] = ln[len("Body:"):].strip()
                elif ln.startswith("Flag:"):
                    current['Flag'] = ln[len("Flag:"):].strip()
                elif ln.startswith("Read:"):
                    current['Read'] = ln[len("Read:"):].strip()
                else:
                    # non standard lines appended to body
                    if 'Body' in current:
                        current['Body'] += " " + ln
                    else:
                        current['Body'] = ln
            if current:
                self._create_and_append(current)

    def _create_and_append(self, info):
        """Helper to create Mail/Confidential/Personal objects from parsed info and append to mailbox."""
        try:
            m_id = str(int(info.get('ID', '0')))
        except:
            m_id = info.get('ID', '0')
        frm = info.get('From', '')
        to = info.get('To', '')
        date = info.get('Date', '')
        subject = info.get('Subject', '')
        tag = info.get('Tag', '')
        body = info.get('Body', '')

        # Create appropriate object depending on tag
        if tag == "conf":
            obj = Confidential(m_id, frm, to, date, subject, tag, body)
        elif tag == "prsnl":
            obj = Personal(m_id, frm, to, date, subject, tag, body)
        else:
            obj = Mail(m_id, frm, to, date, subject, tag, body)

        # set flag/read if present in raw info (optional)
        if info.get('Flag', '').lower() == 'true':
            obj.flag = True
        if info.get('Read', '').lower() == 'true':
            obj.read = True

        self._mailbox.append(obj)

    # FA.1
    def get_email(self, m_id):
        """Return the Mail object whose m_id matches or None."""
        for e in self._mailbox:
            if str(e.m_id) == str(m_id):
                return e
        return None

    # FB.1
    def show_emails(self):
        """Display (pretty print) all Mail objects in the mailbox."""
        if not self._mailbox:
            print("Mailbox is empty.")
            return
        for e in self._mailbox:
            print(e.show_email())

    # FA.3
    def del_email(self, m_id):
        """Delete by moving to bin: change tag to 'bin'."""
        email = self.get_email(m_id)
        if email:
            email.tag = "bin"
            print("Moved to bin:")
            print(email.show_email())
            return email
        else:
            print(f"No email with ID {m_id}")
            return None

    # FA.4
    def filter(self, frm):
        """Return list of emails from given sender (substring match permitted)."""
        frm = frm.strip()
        results = [e for e in self._mailbox if frm in e.frm]
        return results

    # FB.2
    def mv_email(self, m_id, tag):
        """Move email to given tag (folder) by setting _tag."""
        email = self.get_email(m_id)
        if email:
            # If moving to conf/prsnl we should convert object type accordingly for special behaviours
            if tag == "conf" and not isinstance(email, Confidential):
                # create new Confidential preserving m_id etc
                new_e = Confidential(email.m_id, email.frm, email.to, email.date, email.subject, tag, email.body)
                # replace in mailbox
                for i, e in enumerate(self._mailbox):
                    if e.m_id == email.m_id:
                        self._mailbox[i] = new_e
                        email = new_e
                        break
            elif tag == "prsnl" and not isinstance(email, Personal):
                new_e = Personal(email.m_id, email.frm, email.to, email.date, email.subject, tag, email.body)
                for i, e in enumerate(self._mailbox):
                    if e.m_id == email.m_id:
                        self._mailbox[i] = new_e
                        email = new_e
                        break
            else:
                email.tag = tag
            print("Moved:")
            print(email.show_email())
            return email
        else:
            print(f"No email with ID {m_id}")
            return None

    # FB.3
    def mark(self, m_id, mrk_type):
        """Mark as 'read' or 'flag'."""
        email = self.get_email(m_id)
        if not email:
            print(f"No email with ID {m_id}")
            return None
        if mrk_type == "read":
            email.read = True
        elif mrk_type == "flag":
            email.flag = True
        else:
            print("Unknown mark type.")
            return None
        print("Marked:")
        print(email.show_email())
        return email

    # FB.4
    def find(self, date_str):
        """Return list of emails received on given date string."""
        return [e for e in self._mailbox if e.date == date_str]

    # FA.6 & FB.6
    def _generate_unique_m_id(self):
        """Find numeric max id in mailbox and produce next id as string."""
        max_id = -1
        for e in self._mailbox:
            try:
                val = int(e.m_id)
                if val > max_id:
                    max_id = val
            except:
                pass
        return str(max_id + 1)

    def add_email(self, frm, to, date, subject, tag, body):
        """Create appropriate Mail/Confidential/Personal object, assign unique m_id, append to mailbox."""
        m_id = self._generate_unique_m_id()
        if tag == "conf":
            new_mail = Confidential(m_id, frm, to, date, subject, tag, body)
        elif tag == "prsnl":
            new_mail = Personal(m_id, frm, to, date, subject, tag, body)
        else:
            new_mail = Mail(m_id, frm, to, date, subject, tag, body)
        self._mailbox.append(new_mail)
        print("Added email:")
        print(new_mail.show_email())
        return new_mail
